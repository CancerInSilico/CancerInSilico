---
title: "Drug Sensitivity Simulation"
author: "Thomas D. Sherman, Raymond Cheng"
date: "`r doc_date()`"
package: "`r pkg_ver('CellModel')`"
bibliography: References.bib
vignette: >
  %\VignetteIndexEntry{Drug Sensitivity Simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---

```{r include=FALSE, cache=FALSE}
library(CellModel)
```

# Introduction

The main objective of the *CellModel* package is to provide R implementations of a broad class of cell-based models [see @SZABO2013] and provide a single, consistent interface to execute the models. The currrent version of CellModel contains a basic, off-lattice model of cell growth. This model is based off the work in [see @DRASDO2003]. This model was chosen to be implemented first since it is a very basic model that provides enough infastructure to test some simple ideas related to drug response and resistance.

# Basic Simulation

The main function in the package is *runModel*, which can be called with only two parameters - inital number of cells and number of hours to run the simulation (in terms of model time). *runModel* returns a *CellModel* object which contains two fields - cells and parameters. While the simulation runs it periodically displays the current time in the model (hr) and the number of cells.

```{r}
basic_sim <- runModel(10,24)
```

The *cells* field is a list containing vectors of information about the cells at each timestep.

```{r}
basic_sim@cells[[1]]
```

This is raw data that is not meant to be interacted with directly. Instead use the package functions to extract useful information from the simulation.

The parameters field contains a vector of parameters.

```{r}
basic_sim@parameters
```

Although the parameters can be retrieved this way it is preferrable to use *getParameters*.

```{r}
getParameters(basic_sim)
```

## Parameter Overview

There are 9 parameters for *runModel*, although only the first two need to be provided (initialNum, runTime).

*initialNum* - the number of cells in the simulation at time zero  
*runTime* - the number of simulated hours in the run  
*density* - the initial density of the cells  
*cycleLengthDist* - the distribution of cell-cycle length (hrs)  
*inheritGrowth* - T/F for whether cells inherit cell-cycle length from parent  
*timeIncrement* - the number of simulated hours for each MC step  
*outputIncrement* - the number of MC steps between each display of time, size  
*randSeed* - the random seed used for the simulation  
*epsilon* - model specific parameter from Drasdo, 2003

## Parameter Details

*initialNum*, *density*

The cells are initially seeded randomly throughout a circle, whose radius is calculated based on the density parameter. *density* in this case is defined as
the ratio of the total area of the cells and the area of the circle. Providing a *density* higher than 0.1 will result in an error, since the program cannot efficiently seed cells that close together. Cells are seeded randomly throughout the cell-cycle.

*runTime*, *cycleLengthDist*, *timeIncrement*, *outputIncrement*

The model does not have a length scale so the dimensions of the cells are arbitrary, but it does have a time scale. The value passed in *cycleLengthDist* is the average length (in terms of simulation hours) of the cell-cycle for a cell in isolation. *runTime* is the number of simulation hours the model runs for. If a vector is passed in *cycleLengthDist* then it is treated as a distribution of times and each cell is assigned a random value (uniform) from this vector when it is born. *timeIncrement* is the amount of time (hours) that passes during each MC step of the simulation. Note that if *timeIncrement* is too large to accurately simulate the model (given the other parameters) then it will automatically be set to an appropiate value. *outputIncrement* specifices how many MC steps are in between each display in the console. Thus, *outputIncrement* * *timeIncrement* will be the hours in between each display.

*inheritGrowth*

Cells have the option of inheriting the cycle-length from their parent or sampling from *cycleLengthDist* when they are born. This allows for "growth" rates to be affected in a heritable way. This functionality is explored more in section 3.

*epsilon*

This is a model specific parameter. For a more detailed explanation see Draso, 2003. Note that the effective energy F_T is set to 1 is this version of the model.

*randSeed*

The user can pass in a random seed of their choosing. All random samples in the model will be affected by this seed. The default seed is 0.

## Simple Run

The following is essentially the most basic use of the model. It will be used to demonstrate the package functions available.

```{r}
simple_run <- runModel(initialNum = 150,
                       runTime = 168,
                       density = 0.04,
                       cycleLengthDist = 12,
                       inheritGrowth = F,
                       timeIncrement = 0.2,
                       outputIncrement = 144,
                       randSeed = 10,
                       epsilon = 2)
```

## Output Analysis - Package Functions

There are several functions used to get relevant information from the *CellModel* object. It is not recommended to pull data directly from the *cells* field as this is just the raw data from the simulation.

### *getTotalCells*

```{r}
t <- getTotalCells(simple_run)
end <- getParameters(simple_run)$runTime
outInc <- getParameters(simple_run)$outputIncrement
plot(1:length(t), t, type = "l", xaxt="n", xlab="time", ylab="# of cells")
axis(1, at = seq(1,length(t),outInc), labels = seq(0,end,length.out=length(t)/outInc))
```

### *getCycleLengthDistribution*

```{r}
cyc_len <- getCycleLengthDistribution(simple_run,0)
mean(cyc_len)
var(cyc_len)
plot(density(cyc_len), main="Time 0",xlab="Cycle Length")
```

### *getDensity*

```{r}
den <- c()
for (i in 0:72) {
  den[i] <- getDensity(simple_run,i)
}
plot(0:72,den,type="l",xlab="time",ylab="cell density")
```

### *plotCellsAtTime*

```{r}
plotCellsAtTime(simple_run,0)
plotCellsAtTime(simple_run,72)
```

### *plotInteractive*

```
Basic Commands: 
 b = back one timestep 
 n = forward one timestep 
 s = summary of cells 
 q = quit "console"
 h = basic command help
```

The *plotInteractive* function is similiar to *plotCellsAtTime* except there are additional commands that allow the user to step through the simulation and watch it progress as well as query information at the current time.

# Simulating Drug Response

Since the model allows for a distribution of cell-cycle lengths, it is possible to simulate the effects of a drug that suppresses proliferation. In addition, when *inheritGrowth* is true cells will pass down their cell-cycle lengths. This allows the user to simulate varying effectiveness of a drug due to heritable traits, sucha as a mutation.

## Simple Case

In the simple case, we can consider a population of cells that are either effected or not effected by a drug that suprresses proliferation.

```{r}
drug_prop = c(rep(12,100),rep(36,100))
run1 <- runModel(200,100,0.005,outputIncrement=80,cycleLengthDist=drug_prop, inheritGrowth=T)
run2 <- runModel(200,100,0.005,outputIncrement=80,cycleLengthDist=drug_prop, inheritGrowth=F)

prop1 = c()
prop2 = c()

for (i in 1:100) {
  prop1[i] = sum(getCycleLengthDistribution(run1,i) == 12) / length(getCycleLengthDistribution(run1,i))
  prop2[i] = sum(getCycleLengthDistribution(run2,i) == 12) / length(getCycleLengthDistribution(run2,i))
}

plot(1:100,ylim=c(0.3,0.6),prop1,type="l", col="red",xlab="time",ylab="resistant population proportion")
lines(1:100,prop2)
```

Here the red line is for the simulation where cycle times are inherited, and the black line is for the simulation where cycle times are random. This could be thought of as a heritable mutation driving the resistance to the drug. Over time we would expect the cells that posses the mutation to make up a larger and larger percentage of the population.

## Advanced Case

In this simulation, we assume the drug does not have a binary effect on the cycle time, but rather effects the cycle according to some distribution. The question here would
```{r}
adv_case <- runModel(100,200,0.001,growthRates=8 + 8 * rbeta(10000,1,3),outputIncrement=120,inheritGrowth=T)

plot(density(getGrowthRateDistribution(run4,1)))
plot(density(getGrowthRateDistribution(run4,200)))

mean(getGrowthRateDistribution(run4,1))
mean(getGrowthRateDistribution(run4,200))
```

## References
